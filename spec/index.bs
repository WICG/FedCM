<pre class='metadata'>
Title: Federated Credential Management API
Shortname: FedCM
Level: 1
Status: w3c/CG-DRAFT
Group: fedidcg
ED: https://fedidcg.github.io/FedCM/
Repository: fedidcg/FedCM
Editor: Sam Goto, Google Inc. https://google.com, goto@google.com

Markup Shorthands: markdown yes, biblio yes
Default Biblio Display: inline

Text Macro: FALSE <code>false</code>
Text Macro: TRUE <code>true</code>
Text Macro: RP Relying Party
Text Macro: IDP Identity Provider

Abstract: A Web Platform API that allows users to login to websites with their federated accounts in a privacy preserving manner.

Test Suite: https://github.com/web-platform-tests/wpt/blob/master/credential-management/webid.https.html
</pre>

<pre class=anchors>
spec: ecma262; urlPrefix: https://tc39.github.io/ecma262/
    type: dfn
        text: time values; url: sec-time-values-and-time-range
        text: promise; url: sec-promise-objects
        text: internal method; url: sec-ordinary-object-internal-methods-and-internal-slots

spec: credential-management-1; urlPrefix: https://w3c.github.io/webappsec-credential-management/
    type: dictionary
        text: CredentialRequestOptions; url: dictdef-credentialrequestoptions
    type: enum
        text: CredentialMediationRequirement; url: enumdef-credentialmediationrequirement
    for: Credential
        type: method
            text: [[CollectFromCredentialStore]](origin, options, sameOriginWithAncestors)
            text: [[Create]](origin, options, sameOriginWithAncestors)
            text: [[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)
            text: [[Store]](credential, sameOriginWithAncestors)
    type: dfn
        text: signal
        text: same-origin with its ancestors; url: same-origin-with-its-ancestors

spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
    type: dfn
        text: origin; for: html-origin-def; url: origin.html#concept-origin
        text: Content-Type Metadata; url: urls-and-fetching.html#content-type


spec: webidl; urlPrefix: https://webidl.spec.whatwg.org/
    for: Promise
        type: dfn
            text: reject
            text: resolve

</pre>

<pre class=link-defaults>
spec:infra; type:dfn; text:list
spec:infra; type:dfn; text:user agent
spec:html; type:dfn; for:environment settings object; text:global object
spec:html; type:dfn; for:html-origin-def; text:origin
spec:webidl; type:dfn; text:resolve
</pre>

<style>
dl.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
dl.domintro dt a {
    color: inherit; border-bottom-style: none;
}
dl.domintro dt code {
    font-size: inherit;
}
</style>

<script src="https://fedidcg.github.io/FedCM/static/underscore-min.js"></script>
<script src="https://fedidcg.github.io/FedCM/static/raphael.min.js"></script>
<script src="https://fedidcg.github.io/FedCM/static/webfont.js"></script>
<script src="https://fedidcg.github.io/FedCM/static/typogram.js"></script>

<!-- ============================================================ -->
# Introduction # {#introduction}
<!-- ============================================================ -->

*This section is non-normative.*

As the web has evolved there have been ongoing privacy-oriented changes
(e.g [Safari](https://webkit.org/blog/10218/full-third-party-cookie-blocking-and-more/),
[Firefox](https://blog.mozilla.org/blog/2019/09/03/todays-firefox-blocks-third-party-tracking-cookies-and-cryptomining-by-default/),
[Chrome](https://blog.google/products/chrome/privacy-sustainability-and-the-importance-of-and/))
and changes to the underlying privacy principles (e.g. [[PRIVACY-MODEL]]).

With this evolution, fundamental assumptions of the web
platform are being redefined or removed. Access to cookies in a third-party
context are one of those assumptions. While overall good for the
web, the third-party cookie deprecation removes a fundamental building block
used by certain designs of federated identity.

The Federated Credential Management API aims to bridge the gap for the
federated identity designs which relied on third-party cookies.
The API provides the primitives needed to support federated identity when/where
it depends on third-party cookies, from sign-in to sign-out and revocation.

In order to provide the federated identity primitives without the use of
third-party cookies the API places the [=User Agent=] as a mediator between
[=RPs=] and [=IDPs=]. This mediation requires user consent before permitting
the [=RPs=] and [=IDPs=] to know about their connection to the user.

<script type="text/typogram">
┌─────────────────────────────────┐       ┌─────────────────────────────────┐
| ┌─────────────────────────────┐ |       | ┌─────────────────────────────┐ |
| | "https://rp.example"        | |       | | "https://rp.example"        | |
| └─────────────────────────────┘ |       | └─────────────────────────────┘ |
| ┌─────────────────────────────┐ |       | ┌─────────────────────────────┐ |
| |                             | |       | |                             | |
| |   Welcome to my website!    | |       | |  Welcome to my website!     | |
| |                             | |       | |                             | |
| |                             | |       | |                             | |
| +─────────────────────────────+ |       | +─────────────────────────────+ |
| |       Choose an account     | |       | |    Sign-in to rp.example    | |
| |   to sign-in to rp.example  | |       | |      with idp.example?      | |
| |                             | |       | |                             | |
| | ┌────┐                      | |       | | ┌────┐                      | |
| | | :) |  John Doe            | |  ──►  | | | :) |  John Doe            | |
| | └────┘  john@email.com      | |       | | └────┘  john@email.com      | |
| | ┌────┐                      | |       | |                             | |
| | | :] |  John Doe            | |       | | ┌─────────────────────────┐ | |
| | └────┘  john.doe@work.com   | |       | | |    Continue as John     | | |
| |                             | |       | | └─────────────────────────┘ | |
| └─────────────────────────────┘ |       | └─────────────────────────────┘ |
└─────────────────────────────────┘       └─────────────────────────────────┘
</script>

The specification leans heavily on changes in the [=User Agent=] and [=IDP=]
and minimally on the [=RP=]. The FedCM API provides a way to authenticate,
fetch tokens, revoke the provided tokens, and allow for front-channel logout.

<!-- ============================================================ -->
## Use Cases ## {#use-cases}
<!-- ============================================================ -->

The below use case scenarios illustrate some basic supported flows. Each
supported flow below occurs inside an iframe or in an XHR request. Additional
scenarios, including sample code, are given in the
[[Identity-Use-Cases-in-Browser-Catalog]].

<!-- ============================================================ -->
### Sign-up ### {#use-cases-sign-up}
<!-- ============================================================ -->

A Sign-up occurs when the user is registering a new account at the
[=Relying Party=] using their [=Identity Provider=].

For instance, a user navigates to a [=Relying Party=] in their browser
and creates an account. The [=Relying Party=] displays supported
[=Identity Providers=] to the user who selects their favorite. The user
is prompted "Do you want to create an account with the [=Relying Party=]?".
Upon user agreement an [=account=] is created with the [=Relying Party=] and
the user has a [=session=] initialized.

<!-- ============================================================ -->
### Sign-in ### {#use-cases-sign-in}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to
create an account by going through their [[#use-cases-sign-up]] flow,
there are two ways a user logs into their [=account=] once their [=session=] expires:

<!-- ============================================================ -->
#### Auto Sign-in #### {#use-cases-auto-sign-in}
<!-- ============================================================ -->

Auto Sign-in occurs when the [=Identity Provider=] has already gathered
permissions from the user to share their identity with the [=Relying Party=]
and automatically signs the user in.

For example, the user has previously executed the [[#use-cases-sign-up]] flow
and then changes from their phone to their laptop. On the new device the
user goes to the [=Relying Party=] and selects to sign-in using their
[=Identity Provider=]. The [=Identity Provider=] knows, and proves, the user
has signed up to the [=Relying Party=] and the [=Relying Party=] creates a
new [=session=] for the users [=account=].

<!-- ============================================================ -->
#### Explicit Sign-in #### {#use-cases-explicit-sign-in}
<!-- ============================================================ -->

An explicit sign-in occurs when the [=Identity Provider=] believes it is
necessary to gather an explicit permission from the user to sign into a
[=Relying Party=], typically after the user goes through a
[[#use-cases-sign-out]] flow.

For example, after the user has done the [[#use-cases-sign-out]] flow of the
[=Relying Party=] they decide to log in again. The user visits the
[=Relying Party=] and selects their [=Identity Provider=] to sign-in. The
[=Identity Provider=] knows:
    * the user already has an account with the [=Relying Party=].
    * the user has logged out of the [=Relying Party=].

The user is then prompted, "Do you want to sign-in with the [=Relying Party=]?"
and upon user agreement the [=Relying Party=] creates a new [=session=] with
the users existing [=account=].

<!-- ============================================================ -->
### Sign-out ### {#use-cases-sign-out}
<!-- ============================================================ -->

After a user navigates to a [=Relying Party=] in a browser and decides to
create an [=account=] by going through their [[#use-cases-sign-up]] flow,
there are two ways a user can clear their [=session=]s:

<!-- ============================================================ -->
#### RP Sign-out #### {#use-cases-rp-sign-out}
<!-- ============================================================ -->

The user can log out through the [=Relying Party=] by using a provided
sign-out button or link provided by the [=Relying Party=]. This then
removes the users [=session=] and, when the user visits the [=Relying Party=]
again they will need to go through the [[#use-cases-explicit-sign-in]] flow
in order to establish a new session.

<!-- ============================================================ -->
#### IDP Sign-out #### {#use-cases-idp-sign-out}
<!-- ============================================================ -->

The user can log out through the [=Identity Provider=] by using a provided
sign-out system provided by the [=Identity Provider=]. After using the
sign-out system the [=Identity Provider=] will log the user out of all
[=Relying Parties=] the user has signed into along with logging the user
out of the [=Identity Provider=] itself. Upon returning to any associated
[=Relying Party=], or the [=Identity Provider=], the user will have to
go through the [[#use-cases-explicit-sign-in]] flow.

<!-- ============================================================ -->
### Revocation ### {#use-cases-revocation}
<!-- ============================================================ -->

After a user has created an account with a [=Relying Party=] there are two
ways a user can cancel their account with the [=Relying Party=]:

<!-- ============================================================ -->
#### RP Revocation #### {#use-cases-rp-revocation}
<!-- ============================================================ -->

The user can delete their account through the [=Relying Party=] by using
the provided cancel account system. The [=Relying Party=] informs the
[=Identity Provider=] that the user has deleted (revoked) their account.
When the user returns to the [=Relying Party=] they will need to complete
the [[#use-cases-sign-up]] flow in order to access the site.

<!-- ============================================================ -->
#### IDP Revocation #### {#use-cases-idp-revocation}
<!-- ============================================================ -->

The user can delete their account with a [=Relying Party=] by revoking
[=Relying Party=] access through the [=Identity Provider=]. This can be done
by going to the [=Identity Provider=] and using their revoke access system.
Once access is revoked, when the user returns to the [=Relying Party=] they
will need to complete the [[#use-cases-sign-up]] flow in order to access the
site.

<!-- ============================================================ -->
### Access ### {#use-cases-access}
<!-- ============================================================ -->

The [=Identity Provider=] while authenticating the user may also authorize
access to users resources such as calendars, contacts, etc. The granting
of access can be done at either sign-up or post sign-up by requesting
permission from the user.

For example, a user executes the [[#use-cases-sign-up]] flow with a
[=Relying Party=]. During the flow the [=Relying Party=] has informed the
[=Identity Provider=] they need calendar access for the user. The user will
be presented with a prompt, "Do you want to give access to your Calendar
to the [=Relying Party=]?". The user consents to providing access and when
the flow is complete the [=Relying Party=] shows the user their calendar
entries provided by the [=Identity Provider=].

<!-- ============================================================ -->
# Examples # {#examples}
<!-- ============================================================ -->

This specification extends the {{FederatedCredential}} type and internal
algorithms to allow the exchange of identity between [=IDP=]s and [=RP=]s.
When it succeeds, it returns to the [=RP=] a signed [=id token=] which the
[=RP=] can use to authenticate the user.

<!-- ============================================================ -->
# Single Account Example # {#example-single-user}
<!-- ============================================================ -->
<div class=example>
Example showing how a website allowing for a single logged in account
could be implemented.

```html
<html>
<head>
  <title>Welcome to my Website</title>
</head>
<body>
  <button onclick="login()">Login with idp.example</button>

  <script>
  async function login() {
    // This will prompt when !credential["registered"], but
    // it won’t when credential["registered"].
    // If the user selects an account updates the credential["registered"]
    // state and stores any needed account information.
    // The object will be either registered or unregistered and store information
    // on if the user should be prompted based on the mediation flag.
    return await navigator.credentials.get({
      mediated: “optional”, // “optional” is the default
      federated: {
        providers: [{
          url: "https://idp.example/manifest.json",
          clientId: "123",
          nonce: "456"
        }]
      }
    });
  }
  </script>
</body>
</html>
```
</div>

<!-- ============================================================ -->
# Multiple Account Example # {#example-multiple-account}
<!-- ============================================================ -->
<div class=example>
Example showing how a website allowing for multiple logged in accounts
could be implemented.

```html
<html>
<head>
  <title>Welcome to my Website</title>
</head>
<body>
  <button onclick="login()">Login with idp.example</button>
  <button onclick="multiLogin()">Switch account</button>

  <script>
  async function login() {
    const id = ...; /* site gets stored id if available */
    const credential = await navigator.credentials.get({
      mediation: "optional",
      federated: {
        providers: [{
          url: "https://idp.example/manifest.json",
          clientId: "123",
          hint: id,
          nonce: "456",
        }]
      }
    });
    /* site stores credential id somewhere */
    return credential;
  }

  async function multiLogin() {
    const credential = await navigator.credentials.get({
      mediation: "required",
      federated: {
        providers: [{
          url: "https://idp.example/manifest.json",
          clientId: "123",
          nonce: "456",
        }]
      }
    });
    /* site stores credential id somewhere */
    return credential;
  }

  async function getLoggedInCredential() {
    const id = ...; /* site gets stored id if available */
    return navigator.credentials.get({
      mediation: "silent",
      federated: {
        providers: [{
          url: "https://idp.example/manifest.json",
          clientId: "123",
          hint: id,
        }]
      }
    });
  }
  </script>
</body>
</html>
```
</div>

<!-- ============================================================ -->
# Terminology # {#terminology}
<!-- ============================================================ -->

[[HTML]] defines an [=origin=] as the tuple of a scheme, hostname, and port that
provides the main security boundary on the web.

: <dfn>account</dfn>
:: TODO(goto): find existing definition.

: <dfn>authentication</dfn>
:: Process used by an [=Identity Provider=] to achieve sufficient confidence in
    the binding between the user and a presented identity.

    Note that in some discussions and documentation, the term _authentication_ is
    used to refer to the [=federated sign-in=] process. However, the user does not
    authenticate to the [=RP=] during [=federated sign-in=]. The user
    authenticates to the [=IDP=], which then provides a claim to the [=RP=]
    asserting the user’s identity. The user does not prove their identity to the
    [=RP=].

    See also:
    * [[OIDC-Connect-Core#Terminology]]
    * [[OIDC-Connect-Core#Authentication]]
    * [[SAML-Glossary]]

: <dfn>client id</dfn>
:: Each [=IDP=] assigns to each [=RP=] a [=client id=] to uniquely identify the [=RP=]. Note that
    this ID is dependent on both the [=IDP=] and the [=RP=], but the [=client id=] of an [=RP=] only
    needs to be unique with respect to any other [=client id=] within the same [=IDP=].

: <dfn>directed identifier</dfn>
:: A [=user identifier=] that that is unique for each [=site=] the user visits. A
    goal of anti-tracking policy is to promote [=user identifiers=] to become
    [=directed identifiers=]. See the [[#privacy-threat-model]] for more information.

: <dfn>first party</dfn>
:: The first-party for a user action is the [=party=] that controls the
    [=origin=] of the [=top-level browsing context=] under which the action
    happened. Intuitively, this is the owner of the domain in the browser's URL bar.

    This differs from <a href="https://wiki.mozilla.org/Security/Anti_tracking_policy#Tracking_Definition">Mozilla's definition</a>
    in that Mozilla defines other parties as first parties if the user can easily
    discover which party it is and intends to interact with that party, for
    example to allow sign-in widgets to be first-party.

: <dfn>global identifier</dfn>
:: A string that identifies a particular [=user=] independent of which site
    they're visiting (e.g. email addresses and phone numbers). Users generally
    have relatively few global identifiers and can usually list and recognize
    them. A goal of anti-tracking policy is to prevent [=user identifiers=] from
    becoming [=global identifiers=].

: <dfn>high-level API</dfn>
:: A use case specific API, as opposed to a [=low-level API=]. See also
    [high level vs low level](https://w3ctag.github.io/design-principles/#high-level-low-level).

: <dfn>id token</dfn>
:: TODO(goto): find existing definition.

: <dfn>Identity Provider</dfn>
: <dfn>IDP</dfn>
:: A service that has information about the user and can grant that information
    to [=Relying Parties=].

    See also:
    * [[OIDC-Connect-Core#Terminology]]

: <dfn>joining</dfn>
:: TODO(goto): find existing definition.

: <dfn>low-level API</dfn>
:: A general purpose API, as opposed to a [=high-level API=]. See also
    [high level vs low level](https://w3ctag.github.io/design-principles/#high-level-low-level)

: <dfn>minting</dfn>
: <dfn>minted</dfn>
:: The act of a new token being creating

: <dfn>out-of-band</dfn>
:: Outside of the user agent's context.

: <dfn>party</dfn>
:: Defined by [[tracking-dnt]] as "a natural person, a legal entity, or a set of
    legal entities that share common owner(s), common controller(s), and a group
    identity that is easily discoverable by a user."

: <dfn>Relying Party</dfn>
: <dfn>RP</dfn>
: <dfn noexport>Website</dfn>
:: A service that requests user information from an [=Identity Provider=] for
    [=federated sign-in=] or for other purposes.

    See also:
    * [[OIDC-Connect-Core#Terminology]]
    * [[SAML-Glossary]]

: <dfn>session</dfn>
:: TODO(goto): find existing definition.

: <dfn>Federated sign-in</dfn>
:: Process used by a [=Relying Party=] to obtain a [=user identifier=] from an
    [=Identity Provider=] to which the user performed [=authentication=].

    See also:
    * [[OIDC-Connect-Core]]

: <dfn>site</dfn>
:: A set of [=origins=] that are all [=same site=] with each other. Note that
    there are problems ([[PSL-PROBLEMS]]) with using [=registrable domains=] as
    a logical boundary.

: <dfn>third party</dfn>
:: A third-party for a user action is any party that isn't the [=first party=]
    or the user (the second party).

: <df>unsanctioned tracking</dfn>
:: [[UNSANCTIONED-TRACKING]]

: <dfn>user</dfn>
:: A human or program that controls a user agent.

: <dfn>user identifier</dfn>
:: A pair of a [=site=] and a (potentially-large) integer
    allocated by that site that is used to identify a [=user=] on that site. A
    single user will generally have many user IDs that refer to them, and a single
    site may or may not know that multiple user identifiers refer to the same user.

:  <dfn>Privacy Policy</dfn>
:: The policies described at
    {{client_metadata_endpoint_response/privacy_policy_url}}.

:  <dfn>Terms of Service</dfn>
:: The policies described at
    {{client_metadata_endpoint_response/terms_of_service_url}}.


: <dfn>logged-out</dfn>
:: An account is `logged-out` if the user has either not signed into the account
    or has signed out.

: <dfn>logged-in</dfn>
:: An account is `logged-in` if the user has successfully signed into the account.

: <dfn>registered</dfn>
:: The account is `registered` if the user agent thinks that the user has registered an account in
    the [=RP=] using the account from the [=IDP=].

: <dfn>unregistered</dfn>
:: The account is `unregistered` if it's not registered.

<!-- ============================================================ -->
# High Level Design # {#high-level-design}
<!-- ============================================================ -->

At a high level, the Identity Federation Management API works by the
intermediation of cooperating [=IDP=]s and [=RP=]s.

The [[#idp-api]] and the [[#rp-api]] defines a set of HTTP APIs that cooperating
[=IDP=]s and [=IDP=]s exposes as well as the entry points in the [[#browser-api]]
that they can use.

<script type="text/typogram">
┌───────────┐                  ┌───────────┐                      ┌───────────┐
│           │                  │           │                      │           │
│  Relying  │                  │   User    │                      │  Identity │
│   Party   │                  │   Agent   │                      │  Provider │
│           │                  │           │                      │           │
│           │                  │           │                      │           │
│           │   ┌──────────► *-+ Credential│     ┌────────────► *-+ manifest  │
│           │   │              │ Manager   │     │                │           │
│           │   ├              │ API       │     ├────────────► *-+ accounts  │
│           │   │              │           │     │                │           │
│           │   │              │           │     ├────────────► *-+ client    │
│           │   │              │           │     │                │ metadata  │
│           │   │              │           │     │                │           │
│           │   │              │           │     ├────────────► *-+ id_token  │
│           │   │              │           │     │                │           │
│           │   │              │           │     │                │           │
│           │   │              │           │     │                │           │
│           │   │              │           │     │                │           │
│ ┌───────┐ │   │              │ ┌───────┐ │     │                │ ┌───────┐ │
│ │ JS    ├─┼───┘     ┌────────┼─┤ HTTP  ├─┼─────┘       ┌────────┼─┤ JS    │ │
│ └───────┘ │         │        │ └───────┘ │             │        │ └───────┘ │
│           │         │        │           │             │        │           │
│           │         │        │           │             │        │           │
│           │         │        │           │             │        │           │
│    logout +-*  ◄────┘        │ logoutRPs +-*  ◄────────┘        │           │
│           │                  │           │                      │           │
│           │                  │           │                      │           │
└───────────┘                  └───────────┘                      └───────────┘
</script>

The user agent intermediates in such a matter that makes it impractical for the
API to be used for tracking purposes, while preserving the functionality of
identity federation.

<script type="text/typogram">
    Relying                         User                           Identity
    Party                           Agent                          Provider

      |                               |                               |
      | "navigator.credentials.get()" |                               |
      |------------------------------>|                               |
      |                               |                               |
      |                               | "GET /.well-known/fedcm.json" |
      |                               |------------------------------>|
      |                               |<------------------------------| "{"
      |                               |                               |   "provider_urls: [ ... ]"
      |                               |                               | "}"
      |                               |                               |
      |                               | "GET /manifest.json"          |
      |                               |------------------------------>|
      |                               |<------------------------------| "{"
      |                               |                               |   "id_token_endpoint: ...,"
      |                               |                               |   "accounts_endpoint: ...,"
      |                               |                               |   "client_metadata_endpoint: ...,"
      |                               |                               |   "branding: ...,"
      |                               |                               | "}"
      |                               |                               |
      |                               | "GET client_metadata.php"     |
      |                               | "client_id"                   |
      |                               |------------------------------>|
      |                               |<------------------------------| "{"
      |                               |                               |   "terms_of_service_url: ...,"
      |                               |                               |   "privacy_policy_url: ...,"
      |                               |                               | "}"
      |                               |                               |
      |                               |                               |
      |                               | "GET accounts.php"            |
      |                               | "cookies"                     |
      |                               |------------------------------>|
      |                               |<------------------------------| "{"
      |                               |                               |   "accounts: [ ... ]"
      |                               |                               | "}"
      |                               |                               |
      |                               |                               |
      |                     +---------+                               |
      |                     |         |                               |
      |                     |         |                               |
      |                     |         | "account chooser"             |
      |                     |         |                               |
      |                     |         |                               |
      |                     +-------->|                               |
      |                               |                               |
      |                               |                               |
      |                               |                               |
      |                               | "POST token.php"              |
      |                               | "client_id, cookies, account" |
      |                               |------------------------------>|
      |                               |<------------------------------| "{"
      |                               |                               |   "id_token: ...,"
      |                               |                               | "}"
      |                "{ id_token }" |                               |
      |<------------------------------|                               |
      |                               |                               |
      |                               |                               |
     -+-                             -+-                             -+-
</script>


This document defines the APIs in the following order:

1. The [[#idp-api]]
1. The [[#rp-api]]
1. The [[#browser-api]]

<!-- ============================================================ -->
# The Identity Provider API # {#idp-api}
<!-- ============================================================ -->

The [=IDP=] proactively and cooperatively exposes itself as a comformant agent
by exposing a series of HTTP endpoints:

1. A [[#idp-api-manifest]] endpoint in an agreed upon location that points to
1. An [[#idp-api-accounts-endpoint]] endpoint
1. A [[#idp-api-client-id-metadata-endpoint]] endpoint
1. An [[#idp-api-id-token-endpoint]] endpoint

<!-- ============================================================ -->
## Manifest ## {#idp-api-manifest}
<!-- ============================================================ -->

The manifest discovery endpoint is an endpoint
which serves as a discovery device to other endpoints provided by the
[=IDP=].

The manifest discovery endpoint is fetched:

(a) **without** cookies,
(b) **with** a special [[#Sec-FedCM-CSRF]] header,
(c) **without** a [[RFC9110#header.referer|Referer]] header, and
(c) **without** following [[RFC9110#header.location|HTTP redirects]].

For example:

<div class=example>
```http
GET /manifest.json HTTP/1.1
Host: idp.example
Accept: application/json
Sec-FedCM-CSRF: ?1
```
</div>

The file is parsed expecting [=Manifest=] JSON object.

The <dfn>Manifest</dfn> JSON object has the following properties:

<dl dfn-type="argument" dfn-for="Manifest">
    :   <dfn>accounts_endpoint</dfn> (required)
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-accounts-endpoint]] API.
    :   <dfn>client_metadata_endpoint</dfn> (required)
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-client-id-metadata-endpoint]] API.
    :   <dfn>id_token_endpoint</dfn> (required)
    ::  A URL that points to an HTTP API that complies with the [[#idp-api-id-token-endpoint]] API.
    :   <dfn>branding</dfn> (optional)
    ::  A set of [=Branding JSON=] options.
</dl>

The <dfn>Branding JSON</dfn> enables an [=IDP=] to express their branding
preferences, which may be used by User Agents to customize the user agent
consent prompt.

Note: The branding preferences are deliberately designed to be high level
/ abstract (rather than opinionated about a specific UI structure), to
enable different [=User Agents=] to offer different UI experiences and
for them to evolve independently over time.

It may have the following properties:
<dl dfn-type="argument" dfn-for="manifest_branding">
    :   <dfn>background_color</dfn> (optional)
    ::  Background [=color=] for [=IDP=]-branded widgets such as buttons.
    :   <dfn>color</dfn> (optional)
    ::  [=color=] for text on [=IDP=] branded widgets using
        [=background_color=].
    :   <dfn>icons</dfn> (optional)
    ::  A list of [=Icon JSON=] objects.
</dl>

The <dfn>Icon JSON</dfn> may have the following properties:

<dl dfn-type="argument" dfn-for="manifest_branding_icons">
    :   <dfn>url</dfn> (required)
    ::  The url pointing to the icon image.
        The icon needs to comply with the
        [maskable](https://www.w3.org/TR/appmanifest/#icon-masks) specification.
    :   <dfn>size</dfn> (optional)
    ::  The size of the icon. The icon is assumed to be square and single resolution
        (not a multi-resolution .ico). The size may be omitted if the icon is in
        a vector graphic format (like SVG).
</dl>

The <dfn>color</dfn> is a subset of CSS <<color>> syntax, namely <<hex-color>>s, ''hsl()''s, ''rgb()''s and <<named-color>>.

For example:

<div class=example>
```json
{
  "accounts_endpoint": "/accounts.php",
  "client_metadata_endpoint": "/metadata.php",
  "id_token_endpoint": "/idtokens.php",
  "branding": {
    "background_color": "green",
    "color": "0xFFEEAA",
    "icons": [{
      "url": "https://idp.example/icon.ico",
      "size": 10
    }]
  }
}
```
</div>

<!-- ============================================================ -->
## Accounts List ## {#idp-api-accounts-endpoint}
<!-- ============================================================ -->

The accounts list endpoint provides the list of accounts the user has at the [=IDP=].

The accounts list endpoint is fetched
(a) **with** [=IDP=] cookies,
(b) **with** a special [[#Sec-FedCM-CSRF]] header,
(c) **without** a [[RFC9110#header.referer|Referer]] header, and
(d) **without** following [[RFC9110#header.location|HTTP redirects]].

For example:

<div class=example>
```http
GET /accounts_list.php HTTP/1.1
Host: idp.example
Accept: application/json
Cookie: 0x23223
Sec-FedCM-CSRF: ?1
```
</div>

The response is expected to have the following properties:

<dl dfn-type="argument" dfn-for="accounts_endpoint_response">
    :   <dfn>accounts</dfn> (required)
    ::  A list of [=Account JSON=].
</dl>

Every <dfn>Account JSON</dfn> is expected to have the following properties:

<dl dfn-type="argument" dfn-for="accounts_endpoint_response_accounts">
    :   <dfn>id</dfn> (required)
    ::  The account unique identifier.
    :   <dfn>name</dfn> (required)
    ::  The user's full name.
    :   <dfn>email</dfn> (required)
    ::  The user's email address.
    :   <dfn>given_name</dfn> (optional)
    ::  The user's given name.
    :   <dfn>approved_clients</dfn> (optional)
    ::  A list of [=RP=]s (in the form of [=Client ID=]s) this account is already registered with. Used in the [=sign-up=] to allow the [=IDP=] to control whether to show the [=Privacy Policy=] and the [=Terms of Service=].
</dl>

For example:

<div class=example>
```json
{
 "accounts": [{
   "id": "1234",
   "given_name": "John",
   "name": "John Doe",
   "email": "john_doe@idp.example",
   "picture": "https://idp.example/profile/123",
   "approved_clients": ["123", "456", "789"]
  }, {
   "id": "5678",
   "given_name": "Johnny",
   "name": "Johnny",
   "email": "johnny@idp.example",
   "picture": "https://idp.example/profile/456"
   "approved_clients": ["abc", "def", "ghi"]
  }]
}
```
</div>

<!-- ============================================================ -->
## Client Metadata ## {#idp-api-client-id-metadata-endpoint}
<!-- ============================================================ -->

The client metadata endpoint provides metadata about [=RP=]s.

The client medata endpoint is fetched
(a) **without** cookies,
(b) **with** a special [[#Sec-FedCM-CSRF]] header,
(c) **with** a [[RFC9110#header.referer|Referer]] header indicating the [=RP=]'s origin
    (as if [[referrer-policy#referrer-policy-strict-origin|Referer-Policy: strict-origin]]
    was in use), and
(d) **without** following [[RFC9110#header.location|HTTP redirects]].

The user agent also passes the **client_id**.

For example:

<div class=example>
```http
GET /client_medata.php?client_id=1234 HTTP/1.1
Host: idp.example
Referer: https://rp.example/
Accept: application/json
Sec-FedCM-CSRF: ?1
```
</div>

The file is parsed expecting the following properties:

<dl dfn-type="argument" dfn-for="client_metadata_endpoint_response">
    :   <dfn>privacy_policy_url</dfn> (optional)
    ::  A link to the [=RP=]'s [=privacy policy=].
    :   <dfn>terms_of_service_url</dfn> (optional)
    ::  A link to the [=RP=]'s [=terms of service=].
</dl>

For example:

<div class=example>
```json
{
  "privacy_policy_url": "https://rp.example/clientmetadata/privacy_policy.html",
  "terms_of_service_url": "https://rp.example/clientmetadata/terms_of_service.html"
}
```
</div>

<!-- ============================================================ -->
## ID Token ## {#idp-api-id-token-endpoint}
<!-- ============================================================ -->

The ID Token endpoint is responsible for [=minting=] a new [=id token=] for the user.

The ID Token endpoint is fetched
(a) as a **POST** request,
(b) **with** [=IDP=] cookies,
(c) **with** a [[RFC9110#header.referer|Referer]] header indicating the [=RP=]'s origin
    (as if [[referrer-policy#referrer-policy-strict-origin|Referer-Policy: strict-origin]]
    was in use),
(d) **with** a special [[#Sec-FedCM-CSRF]] header, and
(e) **without** following [[RFC9110#header.location|HTTP redirects]].

It will also contain the following parameters in the request body `application/x-www-form-urlencoded`:

<dl dfn-type="argument" dfn-for="id_token_endpoint_request">
    :   <dfn>client_id</dfn>
    ::  The [=RP=]'s [=client id=].
    :   <dfn>nonce</dfn>
    ::  The request nonce
    :   <dfn>account_id</dfn>
    ::  The account identifier that was selected.
    :   <dfn>disclosure_text_shown</dfn>
    ::  Whether the user agent has explicitly shown to the user what specific information the [=IDP=] intends to share with the [=RP=] (e.g. "idp.example will share your name, email.... with rp.example"), used by the [=sign-up=] algorithm for new users but not by the [=sign-in=] algorithm for returning users.
</dl>

For example:

<div class=example>
```http
POST /fedcm_token_endpoint HTTP/1.1
Host: idp.example
Referer: https://rp.example/
Content-Type: application/x-www-form-urlencoded
Cookie: 0x23223
Sec-FedCM-CSRF: ?1
account_id=123&client_id=client1234&nonce=Ct60bD&disclosure_text_shown=true
```
</div>

The response is parsed as a JSON file expecting the following properties:

<dl dfn-type="argument" dfn-for="id_token_endpoint_response">
    :   <dfn>id_token</dfn>
    ::  The resulting [=id token=].
</dl>

For example:

<div class=example>
```json
{
  "id_token" : "eyJC...J9.eyJzdWTE2...MjM5MDIyfQ.SflV_adQssw....5c"
}
```
</div>

<!-- ============================================================ -->
## <code><dfn data-export="">`Sec-FedCM-CSRF`</dfn></code> ## {#Sec-FedCM-CSRF}
<!-- ============================================================ -->

All FedCM HTTP requests sent by the browser must contain a header
`Sec-FedCM-CSRF` with value `?1`. This allows servers to verify that the request
was initiated by the browser and not untrusted JavaScript because
it is a [=forbidden header name=].

<!-- ============================================================ -->
# The Relying Party API # {#rp-api}
<!-- ============================================================ -->

[=RP=]'s expose a [[#rp-api-logout-endpoint]] to facilitate with [[#use-cases-idp-sign-out]].

<!-- ============================================================ -->
## Logout ## {#rp-api-logout-endpoint}
<!-- ============================================================ -->

When [=IDP=]s call the [[#browser-api-idp-sign-out]] API, every [=RP=] gets a
chance to log the user out (e.g. clear cookies, clear local storage)
via the logout endpoint.

The logout endpoint is an endpoint that is registered with the [=IDP=]
[=out-of-band=].

The logout endpoint is called
(a) with a **GET** and
(b) with the [=RP=]'s cookies.

Note: the logout API introduces a credentialed request from the [=IDP=] to
the [=RP=]s, so it exposes a potential tracking surface area. It is a fairly
limited and controlled tracking area because the logout API is only available
when accounts **and** sessions are already established between the [=IDP=] and
the [=RP=].

<!-- ============================================================ -->
# The Browser API # {#browser-api}
<!-- ============================================================ -->

The Browser API exposes APIs to [=RP=]s and [=IDP=]s to call and intermediates
the exchange of the user's identity.

For [=RP=]s, it allows [=RP=]'s users to [[#use-cases-sign-up]] and
[[#use-cases-sign-in]] with the [[#browser-api-rp-sign-in]] API.

For [=IDP=]s, it allows them to [[#use-cases-idp-sign-out]] the users
of their [=RP=] accounts with the [[#browser-api-idp-sign-out]] API.

The Browser API manages the lifecycle of the user's accounts and sessions with
an internal [[#browser-api-state-machine]].

<!-- ============================================================ -->
## The State Machine ## {#browser-api-state-machine}
<!-- ============================================================ -->

Internally, the FedCM API manages a set of |credential|s which are associated
with an [=RP=] and [=IDP=] pair. Those |credential| objects have different
stages of their accounts. At each stage, the state machine manages the |credential|s
access to the appropriate browser capabilities.

TODO: add an ASCII image to explain how the states fit into the algorithms.

The user agent keepts track of the following state machine for each
(account, [=RP=]) pair:

<dl dfn-type="argument" dfn-for="StateMachine">
    :   <dfn>Account State</dfn>
    ::  Keeps track of whether the user has registered the account in the [=RP=] or not.
         Can be [=registered=] or [=unregistered=] (by default).
    :   <dfn>Session State</dfn>
    ::  Keeps track of whether the user has an open or closed session.
         Can be [=logged-in=] or [=logged-out=] (by default).
</dl>

<!-- ============================================================ -->
## The FederatedCredential Interface ## {#browser-api-federated-credential}
<!-- ============================================================ -->

This specification extends the existing {{FederatedCredential}}'s
interface and internal algorithms to allow the exchange of the user's identity:

<div class=example>
```js
const credential = await navigator.credentials.get({
  federated: {
    providers: [{
      url: "https://idp.example/manifest.json",
      clientId: "123",
      hint: "dan@example.com"
    }]
  }
});
```
</div>

First, it extends the {{FederatedCredential}} interface to allow it to carry an [=id token=]:

<xmp class=idl>
[Exposed=Window, SecureContext]
partial interface FederatedCredential {
  readonly attribute USVString? idToken;
};
</xmp>

<dl dfn-type="argument" dfn-for="FederatedCredential">
    :   <dfn>idToken</dfn>
    ::  The minted ID token
</dl>

Second, this specification overrides the {{FederatedCredential}}'s
<code><dfn for="FederatedCredential" method>
 \[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)</dfn></code>
method, with the algorithm described in the [[#browser-api-rp-sign-in]] section.

To support this extension, a {{FederatedIdentityProvider}} dictionary
is introduced to the {{FederatedCredentialRequestOptions}}:

<xmp class=idl>
partial dictionary FederatedCredentialRequestOptions {
  sequence<(DOMString or FederatedIdentityProvider)> providers;
};
</xmp>

Each {{FederatedIdentityProvider}} represents an [=Identity Provider=] that
the [=Relying Party=] supports (e.g. that it has a pre-registration agreement with).

<xmp class=idl>
dictionary FederatedIdentityProvider {
  required USVString url;
  required USVString clientId;
  USVString nonce;
  USVString hint;
};
</xmp>

NOTE: The {{CredentialRequestOptions/mediation}} flag is currently not used.

The {{CredentialRequestOptions/signal}} is used as an abort signal for the
requests.

<dl dfn-type="argument" dfn-for="FederatedIdentityProvider">
    :   <dfn>url</dfn>
    ::  The URL of the identity provider.
    :   <dfn>clientId</dfn>
    ::  The [=client id=] provided to the [=RP=] out of band by the [=IDP=]
    :   <dfn>nonce</dfn>
    ::  A random number of the choice of the [=RP=]
    :   <dfn>hint</dfn>
    ::  Optional `accountId` hint. Maybe used by the UA when displaying the
         account chooser dialog.
</dl>

<!-- ============================================================ -->
### RP Sign-in ### {#browser-api-rp-sign-in}
<!-- ============================================================ -->

The Sign-up and Sign-in APIs is used by the [=Relying Party=]s to ask the browser
to intermediate the relationship with the [=Identity Provider=] and the
provisioning of an [=id token=].

NOTE: The [=Relying Party=] makes no delineation between Sign-up and Sign-in, but
rather calls the same API indistinguishably.

If all goes well, the [=Relying Party=] receives back a {{FederatedCredential}}
which contains an [=id token=] in the form of a signed [[JWT]] which it can use to
authenticate the user.

The Sign-in API will request the [=id token=] to be [=minted=] by the IDP.

Each {{FederatedCredential}} has an associated <dfn>provider</dfn>, a
{{FederatedIdentityProvider}}, which is initially null.

This algorithm runs in parallel inside the [[CM#algorithm-request]] to request
credentials and returns a set of {{FederatedCredential}} for the requested
[=Identity Provider=]s.

This [=internal method=] accepts three arguments:

<dl dfn-type="argument" dfn-for="FederatedCredential/[[DiscoverFromExternalSource]](origin, options, sameOriginWithAncestors)">
    :   <dfn>origin</dfn>
    ::  This argument is the [=relevant settings object=]'s
         [=environment settings object/origin=], as determined by the
         calling {{CredentialsContainer/get()}} implementation, i.e.,
         {{CredentialsContainer}}'s <a abstract-op>Request a `Credential`</a>
         abstract operation.
    :   <dfn>options</dfn>
    ::  This argument is a {{CredentialRequestOptions}} object whose
         <code>|options|.{{CredentialRequestOptions/federated}}</code> member
         contains a {{FederatedCredentialRequestOptions}} object specifying the
         exchange options.
    :   <dfn>sameOriginWithAncestors</dfn>
    ::  This argument is a Boolean value which is [TRUE] if and only if the
         caller's [=environment settings object=] is
         [=same-origin with its ancestors=]. It is [FALSE] if caller is cross-origin.
</dl>

When this method is invoked, the user agent MUST execute the following algorithm:

  1.  If <var ignore>sameOriginWithAncestors</var> is `false`, return a
      "{{NotAllowedError}}" {{DOMException}}.

      Note: This restriction aims to address the concern raised
      in [[Security-Origin-Confusion]].
  1.  Assert: |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"] [=map/exists=].
  1.  Assert: |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"] [=list/size=] is 1.

       Note: At some point we would like to support choosing accounts from
       multiple [=Identity Provider=]s.
  1. Let |provider| be |options|["{{CredentialRequestOptions/federated}}"]["{{FederatedCredentialRequestOptions/providers}}"][0].
  1. Let |hint| be |provider|["{{FederatedIdentityProvider/hint}}"]
  1. Let |credential| be a new {{FederatedCredential}}.
  1. Set |credential|'s <a>provider</a> to |provider|.
  1. Set |credential|'s {{Credential/id}} to |hint|.
  1. Request user consent by running the [=request consent=] algorithm with the |provider|.
  1. If {{StateMachine/Account State}} is [=unregistered=] then return null.
  1. Let |token| be the result of running the [=create tokens=] algorithm.
  1. Set |credential|'s {{FederatedCredential/idToken}} to |token|.
  1. return |credential|.

To <dfn>request consent</dfn> given a |provider|:
    1. Let |manifest| be the result of running the [=fetch the manifest=]
        algorithm with |provider|.
    1. Let |accounts list| be the result of running the
        [=fetch the accounts list=] algorithm.
    1. Let |account| be the result of running the [=select an account=] from the
        |accounts list| algorithm.
    1. If |account| is null, return.
    1. If the {{StateMachine/Account State}} is [=unregistered=] then run the
        [=sign-up=] algorithm for |account|, and return.
    1. Run the [=sign-in=] algorithm for |account|.

To <dfn>fetch the accounts list</dfn>:
    1. Let the |accounts_endpoint| url be the relative url
        |manifest|["{{Manifest/accounts_endpoint}}"] of
        |provider|["{{FederatedIdentityProvider/url}}"]
    1. Let the |accounts list| be the result of fetching the |accounts_endpoint|
        with the [=Identity Provider=]'s cookies.  This request MUST NOT follow
        [[RFC9110#header.location|HTTP redirects]] and instead abort with an
        error if there are any. See also [[#idp-api-accounts-endpoint]].
        TODO: explain why we must not follow redirects in the security section.
    1. Return the |accounts list|.

To <dfn>sign-up</dfn> the user with a given |account|:
    1. Let |metadata| be the result of running the [=fetch the client metadata=]
        algorithm.
    1. If |metadata|["{{client_metadata_endpoint_response/privacy_policy_url}}"] is defined and
        the provider["{{FederatedIdentityProvider/clientId}}"] is not in the list of |account|["{{accounts_endpoint_response_accounts/approved_clients}}"]
        then display the |metadata|["{{client_metadata_endpoint_response/privacy_policy_url}}"] link.
    1. If |metadata|["terms_of_service_url"] is defined and
        the provider["{{FederatedIdentityProvider/clientId}}"] is not in the list of |account|["{{accounts_endpoint_response_accounts/approved_clients}}"]
	      then display the |metadata|["{{client_metadata_endpoint_response/terms_of_service_url}}"] link.
    1. Prompt the user to gather explicit intent to create an account. The user agent MAY use the
        [=Branding JSON=] to inform the style choices of its UI.
    1. Set the account's {{StateMachine/Account State}} from [=unregistered=]
        to [=registered=].
    1. Set the account's {{StateMachine/Session State}} from [=logged-out=]
        to [=logged-in=].

To <dfn noexport>fetch the client metadata</dfn>:
    1. Let the |client_metadata_endpoint| url be the relative url
        |manifest|["{{Manifest/client_metadata_endpoint}}"] of
        |provider|["{{FederatedIdentityProvider/url}}"]
    1. Let the |policies| be the result of fetching the
        |client_metadata_endpoint| with the [[#Sec-FedCM-CSRF|Sec-FedCM-CSRF]]
        header but without the [=Identity Provider=]'s cookies.  This request
        MUST NOT follow [[RFC9110#header.location|HTTP redirects]] and instead
        abort with an error if there are any. See also [[#idp-api-client-id-metadata-endpoint]].
    1. Return |policies|.

To <dfn>select an account</dfn> from the accounts list:
    1. If |accounts list|'s [=list/size=] is 1:
        1. Let |account| be |accounts list|[0] and return |account|
    1. If this's {{FederatedCredential/provider}}["accountId"] is provided and
        an account matches this's {{FederatedCredential/provider}}["accountId"] then return
        |account|.
    1. Display an account chooser
    1. Let |account| be an account that the user manually selects from the
        accounts chooser, or null if no account is selected.
    1. Return |account|

To <dfn>sign-in</dfn> the user:
    1. Assert that the {{StateMachine/Account State}} is [=registered=]
    1. Set the account's {{StateMachine/Session State}} from [=logged-out=] to
        [=logged-in=].

To <dfn>create tokens</dfn>:
    1. Assert {{StateMachine/Account State}} is [=registered=]
    1. Assert {{StateMachine/Session State}} is [=logged-in=]
    1. Let |request| be a new object
        1. Set |request|["account_id"] to |account|["{{accounts_endpoint_response_accounts/id}}"].
        1. Set |request|["client_id"] to |provider|["{{FederatedIdentityProvider/clientId}}"].
        1. Set |request|["nonce"] to |provider|["{{FederatedIdentityProvider/nonce}}"].
    1. Let |tokens| be the result of making a POST request described in
        [[#idp-api-id-token-endpoint]].
    1. Return |tokens|["id_token"].

The <dfn>fetch the manifest</dfn> algorithm accepts a {{FederatedIdentityProvider}} |provider| and returns a [=Manifest=] object:
    1. In parallel, perform the following two steps:
        1. Let |manifestInSet| be the result of running [=check the root manifest=], passing
            |provider|.
        1. Let |manifest| be the result of running [=fetch the internal manifest=], passing
            |provider|.
    1. If |manifestInSet| is true, return |manifest|, otherwise abort with an error.

NOTE: We use a two-tier manifest list in order to prevent the [=IDP=] to easily determine the [=RP=]
that a user is visiting by encoding the information in the manifest path. We solve this issue by
requiring a manifest list to be on the root of the [=IDP=]. The manifest itself can be anywhere, but
it will not be used if the user agent does not find it in the manifest list. This allows the [=IDP=]
to keep their actual manifest on an arbitary path while allowing the user agent to prevent manifest
manipulation to fingerprint. See https://github.com/fedidcg/FedCM/issues/230 for more details on
this attack.

The <dfn>check the root manifest</dfn> accepts a {{FederatedIdentityProvider}} |provider| and whether the manifest is included in the manifest list:
    1. Let |url| be |provider|'s {{FederatedIdentityProvider/url}}.
    1. Let |rootUrl| be a new [=/URL=].
    1. Set |rootUrl|'s [=url/scheme=] to |url|'s [=url/scheme=].
    1. Set |rootUrl|'s [=url/host=] to |url|'s [=url/host=]'s [=host/registrable domain=].
    1. Set |rootUrl|'s [=url/path=] to ".well-known/fedcm.json".
    1. Let |request| be a new <a spec=fetch for=/>request</a> whose [=request/url=] is |rootUrl| and
        [=request/redirect mode=] set to "error". TODO: what other fields need to be set?
    1. [=Fetch=] |request| with <a spec=fetch>processResponseConsumeBody</a> set to the following
        steps given a <a spec=fetch for=/>response</a> |response|:
        1. If |response| is a [=network error=] or its [=response/status=] is not an [=ok status=],
            return false.
        1. If |response|'s [=Content-Type Metadata=] is not a [=JSON MIME Type=], return false.
        1. Let |json| be the result of [=parse JSON bytes to an Infra value=] passing |response|'s
            [=response/body=].
        1. If |json| is a parsing exception, or if |json| is not an [=ordered map=], return false.
        1. If |json|["provider_urls"] does not exist, or if it is not a [=list=], return false.
        1. If the [=list/size=] of |json|["provider_urls"] is greater than 1, return false. TODO:
            determine the right value, probably greater than 1.
        1. If |json|["provider_urls"][0] is not a [=string=], return false.
        1. Return true if |json|["provider_urls"][0] [=string/is=] equal to |provider|'s
            {{FederatedIdentityProvider/url}}, otherwise return false.

The <dfn>fetch the internal manifest</dfn> algorithm accepts a {{FederatedIdentityProvider}} |provider| and returns a [=Manifest=]:
    1. Run a [[!CSP]] check with a [[CSP#directive-connect-src|connect-src]]
        directive on the URL passed as |provider|'s {{FederatedIdentityProvider/url}}
        and return if the check fails.
    1. Return the result of fetching the |provider|'s {{FederatedIdentityProvider/url}}
        and parsing it into a [=Manifest=].
        TODO: specify how the fetching and the parsing works.
        The fetch MUST be done with the [[#Sec-FedCM-CSRF|Sec-FedCM-CSRF]] header but
        without the [=Identity Provider=]'s cookies. This request MUST NOT follow
        [[RFC9110#header.location|HTTP redirects]] and instead abort with an
        error if there are any.

<!-- ============================================================ -->
### IDP Sign-out ### {#browser-api-idp-sign-out}
<!-- ============================================================ -->

In enterprise scenarios, it is common for the user to want to clear all of
their existing sessions in all of the [=Relying Party=]s they are logged into.

It does so by being navigated to their [=Identity Provider=] who initiates
what's called a [[Front-Channel-Logout]].

The browser exposes an API that takes the list of [=Relying Party=]s that the
[=Identity Provider=] wants to initiate the logout which are loaded in parallel
with cookies.

Each [=Relying Party=] endpoint is responsible for clearing its local state
(e.g. clearing cookies).

After the completion of this API, the user's session is cleared and will go
through an [[#use-cases-explicit-sign-in]] upon return.

<div class='image'>
<pre class=include-raw>
path: img/mock31.svg
</pre>
</div>

<div class=example>
```js
await FederatedCredential.logoutRPs([{
    url: "https://rp1.example",
    accountId: "123"
  }, {
    url: "https://rpN.example",
    accountId: "456"
  }]);
```
</div>

[=IDP=]s can call <code><a idl for="FederatedCredential" lt="logout()">FederatedCredential.logoutRPs(...)</a></code>
to log the user out of the [=RP=]s they are signed into.

<xmp class=idl>
dictionary FederatedCredentialLogoutRpsRequest {
  required USVString url;
  required USVString accountId;
};

[Exposed=Window, SecureContext]
partial interface FederatedCredential {
  static Promise<undefined> logoutRPs(sequence<FederatedCredentialLogoutRpsRequest> logoutRequests);
};
</xmp>

When this method is invoked, the user agent MUST execute the following algorithm:

  1. Let |promise| be a new {{Promise}}.
  1. For each |request| in |logoutRequests|
    1. Let |credential| be a credential matching
        |request|'s {{FederatedCredentialLogoutRpsRequest/url}} and
        |request|'s {{FederatedCredentialLogoutRpsRequest/accountId}}
    1. If no matching |credential| continue
    1. If the |credential| {{StateMachine/Account State}} is [=unregistered=] or
        {{StateMachine/Session State}} is [=logged-out=] continue
    1. POST to the |request|'s {{FederatedCredentialLogoutRpsRequest/url}} with the
        [=Relying Parties=] cookies.  This request MUST NOT follow
        [[RFC9110#header.location|HTTP redirects]] and instead abort the request.
    1. Set the |credential| {{StateMachine/Session State}} to [=logged-out=]
  1. <a for=Promise>Resolve</a> |promise| with |undefined| and return |promise|.


<!-- ============================================================ -->
## Backwards Compatibility ## {#browser-api-backwards-compatibility}
<!-- ============================================================ -->

Note: go over how we are planning to deal with backwards compatibility.

<!-- ============================================================ -->
# Security # {#security}
<!-- ============================================================ -->

This section provides a few of the security considerations for the FedCM API. Note that there is a
separate section for [[#privacy]] considerations.

<!-- ============================================================ -->
## Content Security Policy ## {#content-security-policy}
<!-- ============================================================ -->

The first fetches triggered by the FedCM API are the manifest list, which is public, and the
internal manifest. Imagine a malicious script included by (and running as) the [=RP=] attempting to
execute the FedCM API calls to a malicious [=IDP=], one which is not trusted by the [=RP=]. If the
call is successful, this would introduce browser UI on the [=RP=] with sign in options into a
malicious [=IDP=]. This malicious[=IDP=] could then attempt to trick the user. The protection
against this attack is the [[!CSP]] check, which would fail because the origin of the manifest of
the malicious [=IDP=] would not be an origin included in the allowlist specified by the [[!CSP]] of
the [=RP=], hence preventing the undesired FedCM UI from being shown. Since any subsequent fetches
are same origin with respect to the internal manifest or at least dependent on the contents of the
internal manifest, they do not require additional checks.

The non-same-origin fetches include, for example, the brand icon. The user agent does not perform a
[[!CSP]] check on these because they are directly specified from the manifest. In addition, the
rendering of this image is performed by the user agent, and as such this image cannot affect the
[=RP=] site nor can they be inspected by the [=RP=] in any way.

<!-- ============================================================ -->
## Sec-FedCM-CSRF ## {#sec-fedcm-csrf}
<!-- ============================================================ -->

The FedCM API introduces several non-static endpoints on the [=IDP=], so these need to be protected
from XSS attacks. In order to do so, the FedCM API introduces the [[#Sec-FedCM-CSRF]] header, a
[=forbidden header name=]. The header cannot be set by random websites, so the [=IDP=] can be
confident that the request was originated by the FedCM browser rather than sent by a websites trying
to run an XSS attack. An [=IDP=] must to check for this header in the credentialed requests it
receives, which ensures that the request was initiated by the user agent, based on the FedCM API. A
malicious actor cannot spam FedCM API calls, so this is sufficient protection for the new [=IDP=]
endpoints.

<!-- ============================================================ -->
## Browser Surface Impersonation ## {#browser-surface-impersonation}
<!-- ============================================================ -->

The FedCM API introduces new (trusted) user agent UI, and the user agent may choose to show the UI
entirely on top of the page's contents, if anything because the page was the one responsible for
this UI. This introduces a potential concern of a malicious site to try to replicate the FedCM UI,
gain the user's trust that the user is interacting with a trusted browser surface, and gather
information from the user that they would only give to the browser rather than the site
(e.g. usernames/passwords of **another** site). This is not possible because the FedCM UI uses the
metadata about the user accounts of the [=IDP=], which the website doesn't have access. If this is
a malicious site, it would not know the user accounts, otherwise the user is already compromised.
In addition, the FedCM UI is deliberately constructed to not prompt the user to provide additional
information, such as username or password. Thus, an attacker trying to impersonate the browser
using exclusively UI that is accessible to the content area (e.g. iframes) to attempt to retrieve
sensitive information from the user would be noticeably different from the FedCM UI. Finally,
because the FedCM UI can only be queried from the top-level frame (or potentially from an iframe
with explicit permission from the top-level frame), the priviledged UI surface is only shown when
the top-level frame wants it so. A sneaky iframe cannot force the FedCM UI to occlude important
content from the main page.

<!-- ============================================================ -->
# Privacy # {#privacy}
<!-- ============================================================ -->

<!-- ============================================================ -->
## Network requests ## {#network-requests}
<!-- ============================================================ -->

The FedCM API introduces the ability for a site to ask the browser to execute a few different
network requests, as shown in the [[#high-level-design]] section. It is important for the browser
to execute these in such a way that it does not allow the user to be tracked (by an attacker
impersonating an [=IDP=]) on to the site using FedCM. The following table has information about the
network requests performed:

<script type="text/typogram">
┌──────────────────────────┬─────────┬───────────┬──────────┐
│ Endpoint                 │ cookies │ client_id │ referrer │
├──────────────────────────┼─────────┼───────────┼──────────┤
│ manifest                 │  no     │  no       │  no      │
├──────────────────────────┼─────────┼───────────┼──────────┤
│ accounts_endpoint        │  yes    │  no       │  no      │
├──────────────────────────┼─────────┼───────────┼──────────┤
│ token_endpoint           │  yes    │  yes      │  yes     │
├──────────────────────────┼─────────┼───────────┼──────────┤
│ client_metadata_endpoint │  no     │  yes      │  yes     │
└──────────────────────────┴─────────┴───────────┴──────────┘
</script>

For fetches that are sent with cookies, we actually consider them equivalent to first-party fetches,
and hence include first-party cookies as if the resource was loaded as a first-party, e.g.
regardless of the
[SameSite](https://httpwg.org/http-extensions/draft-ietf-httpbis-rfc6265bis.html#name-the-samesite-attribute-2)
value (which is used when a resource loaded as a third-party, not first-party). This makes it easy
for an [=IDP=] to adopt the FedCM API without introducing security issues on the API, since the
[=RP=] cannot inspect the results from the fetches in any way.

TODO: explain why we disable following redirects.

* The manifest fetch can't be used to track users because it is performed without cookies, [=client
    id=], or referrer. Thus, anyone could perform this fetch, and the information contained therein
    is considered public.

* The accounts fetch can't be used to track users because it is performed with cookies from the
    [=IDP=] but, importantly, without the [=client id=] or referrer. This in theory is a new power
    that the [=RP=] gains that it would not have otherwise. Preventing too many of these fetches may
    be important, but [=IDP=]s are already expected to protect against DoS attacks. In addition, the
    user agent should only allow one FedCM flow per page at any given moment, immediately rejecting
    any attempts to start another one. Since a FedCM flow can only be terminated when the user
    interacts or after a long timer, the number of fetches performed is not a concern. The [=IDP=]
    does learn a lot about the user from this fetch, but this is discussed in detail below.

* The client metadata fetch can't be used to track users too because it is performed without cookies
    from the [=IDP=], albeit with a [=client id=] and a referrer. This allows the [=IDP=] to
    communicate the relevant [=Privacy Policy=] and [=Terms of Service=] to the user agent, in case
    they need to be displayed. Again, besides possible timing attacks described here, the [=RP=]
    gains nothing from this fetch, and the [=RP=] could already perform this fetch if it wanted to
    since it involves no cookies from the [=IDP=].

* By design, the token fetch exposes the user at the website to the [=IDP=]: it is
    peformed with cookies, [=client id=], and referrer. Because of that, it is gated on the user
    interacting with the user agent UI, and enables the [=IDP=] to communicate to the [=RP=] the
    information required to perform a federated signin/signup. It is not possible for the [=RP=] or
    the [=IDP=] to force the token fetch to happen without user consent, as the user agent cannot be
    spoofed or otherwise tricked.

<!-- ============================================================ -->
## Privacy Threat Model ## {#privacy-threat-model}
<!-- ============================================================ -->

This section is intended to provide a comprehensive overview of the privacy
risks associated with federated identity on the web for the purpose of
measuring the privacy risks and benefits of proposed browser intermediation
designs.

See also:

    * [[PRINCIPLES]]
    * [[ETHICS]]
    * [[SELF-REVIEW#threats]]
    * [[PRIVACY-CONSIDERATIONS#privacy-threats]]
    * [[RFC6973#section-5]]
    * [[PRIVACY-MODEL]]
    * [Editor’s Draft for a Web Privacy Threat Model](https://w3cping.github.io/privacy-threat-model/)
    * [Security and Privacy Considerations for SAML V2.0](https://docs.oasis-open.org/security/saml/v2.0/saml-sec-consider-2.0-os.pdf)

<!-- ============================================================ -->
### Principals ### {#privacy-threat-model-principals}
<!-- ============================================================ -->

This section describes the three principals that would participate in an
invocation of the API and expectations around their behavior.

1. The [=User Agent=] implements [[#browser-api]] and controls the execution
    contexts for the [=RP=] and [=IDP=] content. The user agent is assumed to be
    trusted by the user, and transitively trusted by the RP and IDP.
1. [=Relying Party=]s ([=RP=]s) are [=first party=] websites that invoke the
    FedCM API for the purpose of authenticating a user to their account or for
    requesting information about that user. A well-behaving RP would only invoke
    the API following a clear user signal -- typically, clicking a sign-in
    button. Since any site can invoke the API, RPs cannot necessarily be trusted
    to limit the user information it collects or use that information in an
    acceptable way.
1. [=Identity Provider=]s ([=IDP=]s) are [=third party=] websites that are the
    target of a FedCM call to attempt to fetch an ID token. Usually the IDP has a
    higher level of trust than the RP since it already has the user’s personal
    information, but it is possible that the IDP might use the user’s information
    in non-approved ways. It is possible that the IDP specified in the API call
    may not be an IDP the user knows about, or may not be a bona fide IDP at all,
    in which case it likely does not have personal user information in advance,
    but also might be less accountable for its behavior.

<!-- ============================================================ -->
### High-level threats ### {#privacy-threat-model-high-level-threats}
<!-- ============================================================ -->

[[RFC6973]] describes the following high-level privacy threats, which the TAG
has adopted into [[security-privacy-questionnaire#threats]]:

: <dfn noexport>Surveillance</dfn>
:: Surveillance is the observation or monitoring of an individual’s
    communications or activities.

: <dfn noexport>Stored Data Compromise</dfn>
:: End systems that do not take adequate measures to secure stored data from
    unauthorized or inappropriate access.

: <dfn noexport>Intrusion</dfn>
:: Intrusion consists of invasive acts that disturb or interrupt one’s life or
    activities.

: <dfn noexport>Misattribution</dfn>
:: Misattribution occurs when data or communications related to one individual
    are attributed to another.

: <dfn noexport>Correlation</dfn>
:: Correlation is the combination of various pieces of information related to an
    individual or that obtain that characteristic when combined.

: <dfn noexport>Identification</dfn>
:: Identification is the linking of information to a particular individual to
    infer an individual’s identity or to allow the inference of an individual’s
    identity.

: <dfn noexport>Secondary Use</dfn>
:: Secondary use is the use of collected information about an individual without
    the individual’s consent for a purpose different from that for which the
    information was collected.

: <dfn noexport>Disclosure</dfn>
:: Disclosure is the revelation of information about an individual that affects
    the way others judge the individual.

: <dfn noexport>Exclusion</dfn>
:: Exclusion is the failure to allow individuals to know about the data that
    others have about them and to participate in its handling and use.

These threats combine into the particular concrete threats we want web
specifications to defend against, described in subsections here:

<!-- ============================================================ -->
### Attack Scenarios ### {#attack-scenarios}
<!-- ============================================================ -->

This section describes the scenarios in which various agents might attempt to
gain user information. It considers the possibilities when:
    * [[#attack-scenarios-by-rp|The RP is collecting information]],
    * [[#attack-scenarios-by-idp|The IDP is collecting information]], or
    * [[#attack-scenarios-by-idp-by-collusion|Both the RP and the IDP are colluding]].

For the purposes of this section, a principal is considered to be participating
in the collection of information if it directly or indirectly performs actions
with the aim of realizing one of the above threats.

Note: An example of indirect collusion would be an RP importing a script
supplied by an IDP where the IDP intends to track users.

For the purpose of discussion this document assumes that third-party cookies
are **disabled** by default and are no longer effective for use in tracking
mechanisms, and also some form of mitigations are implemented against ‘bounce
tracking’ using link decoration or postMessage. Most of these scenarios consider
how user tracking might happen **without** them.

See also:
    1. [[RFC7258]]

<!-- ============================================================ -->
#### By the RP #### {#attack-scenarios-by-rp}
<!-- ============================================================ -->

<!-- ============================================================ -->
##### Cross-Site Correlation ##### {#attack-scenarios-by-rp-cross-site-correlation}
<!-- ============================================================ -->

Related to:
    * [[PRIVACY-THREAT-MODEL#hl-recognition-cross-site]]
    * [[PRIVACY-CONSIDERATIONS#privacy-threats| Privacy Considerations for Web Protocols: Correlation]]
    * [[RFC6973#section-5.2.1|RFC6973: Correlation]]

Correlation is the combination of various pieces of information related to an
individual or that obtain that characteristic when combined.

This attack happens when multiple [=RP=]s collude to use their user's data to
correlate them and build a richer profile.

When a user willingly provides their full name, email address, phone number, etc,
to multiple relying parties, those relying parties can collaborate to build a
profile of that user and their activity across collaborating sites.

Sometimes this is referred to as [=joining=] since it amounts to a join of user
ecords between the account databases of multiple RPs.

This correlation and profile-building is outside the user’s control and entirely
out of the [=User Agent=]’s or [=IDP=]’s view.

<div class="image">
   <pre class=include-raw>
   path: img/mock3.svg
   </pre>
</div>

<div class="example">
    1. User signs into RP1 (which sells jewelry) with an IDP, providing to RP1
        their email address user@email.example
    1. User signs into RP2 (which sells houses) with an IDP, providing to RP2
        their email address user@email.example
    1. User browses the collection of wedding rings in RP1.
    1. Out of band, RP1 tells RP2 that user@email.example is shopping for wedding rings
    1. User browses the housing inventory in RP2.
    1. RP2 uses the fact that the user is shopping for wedding rings in RP1 to
        advertise and filters their housing inventory.
    1. User is surprised that RP2 knows that they are shopping for wedding rings.
</div>

A generalization of [[#attack-scenarios-by-rp-cross-site-correlation]] is:

(<dfn noexport>RP Secondary Use</dfn>) Relying Party uses user information for
purposes not authorized by the user:

When the user agrees to allow the IDP to provide information to the RP,
the consent is specific to certain purposes, such as sign-in and personalization.
The RP might use that data for other purposes that the user would not expect and
did not authorize, such as selling email addresses to a spam list.

Spamming risk can exist even when using [=directed identifiers=].

<!-- ============================================================ -->
##### Same-Site Identification ##### {#attack-scenarios-by-rp-same-site-identification}
<!-- ============================================================ -->

Identification is the linking of information to a particular individual
to infer an individual’s identity or to allow the inference of an
individual’s identity.

This attack happens when the Relying Party employs client state-based
tracking to identify user.

Any API that exposes any kind of client state to the web risk becoming a
vector for fingerprinting or ‘supercookies’.

This risk would be increased by any proposal for browser mediation that
adds directly (or indirectly) detectable client state.

<div class="image">
<pre class=include-raw>
path: img/mock5.svg
</pre>
</div>

<div class='example'>
For example, an RP can use the browser state of the FedCM to add bits of entropy
and fingerprint the user.
</div>

See also:

   1. [[FINGERPRINTING-GUIDANCE]]

<!-- ============================================================ -->
##### Data Compromise ##### {#attack-scenarios-by-rp-data-compromise}
<!-- ============================================================ -->

This attack scenario happens when the [=RP=] takes advantage of
inadequate measures (by the [=IDP=] or the UA) to secure stored data to
obtain personal user information without their consent.

This can happen if user consent mechanisms are missing, inadequate,
or susceptible to bypass.

<div class="example">
An RP can use clickjacking to trick the user into signing-into their site.
</div>

<div class="example">
An RP can impersonate another RP to phish the user into signing-into their site.
</div>

See also:
    1. [[PRIVACY-THREAT-MODEL#stored-data-compromise]]
    1. [[RFC6973#section-5.1.2]]

<!-- ============================================================ -->
#### By the IDP #### {#attack-scenarios-by-idp}
<!-- ============================================================ -->

<!-- ============================================================ -->
##### Secondary Use ##### {#attack-scenarios-by-idp-secondary-use}
<!-- ============================================================ -->

Related to:
    * [[SELF-REVIEW#third-party-tracking]]

Secondary use is the use of collected information about an individual
without the individual's consent for a purpose different from that
for which the information was collected.

This attack happens when Identity Providers misuses the the information
collected to enable sign-in for other purposes.

Existing federation protocols require that the IDP know which service is
requesting an ID token in order to allow identity federation (e.g. the IDP must
know the OAuth `client_id`).

Identity providers can use this fact to build profiles of users across sites
where the user has decided to use federation with the same account. This profile
could be used, for example, to serve targeted advertisements to those users
browsing on sites that the IDP controls.

This risk can exist even in the case where the IDP does not having pre-existing
user account information (for instance, if it is not a _bona fide_ IDP), because
FedCM requests sent to the IDP are credentialed. This is more likely to occur if
the RP is colluding with the IDP to enable tracking; expanded variants are
described in [[#attack-scenarios-by-idp-timing-attacks]].

<div class="image">
    <pre class=include-raw>
    path: img/mock23.svg
    </pre>
</div>

<div class='example'>
    1. User signs into RP1 (which sells jewelry) with an IDP.
    1. User signs into RP2 (which sells houses) with the same IDP.
    1. User navigates to the IDP.
    1. Because the IDP knows that the user has an account with RP1 and RP2, the
        IDP can show ads about vacations for honeymoons.
    1. The user is surprised that their IDP is aware of their plans to get
        married.
</div>

<!-- ============================================================ -->
##### Impersonation ##### {#attack-scenarios-by-idp-impersonation}
<!-- ============================================================ -->

Since IDPs have unconstrained ability to issue ID tokens, they are capable
of logging in to users’ federated accounts without user knowledge or action,
impersonating the user and potentially gaining full access to the user's account
on the RP.

<div class="example">
    1. User signs into RP1 (which is a online dating site) with an IDP.
    1. An evil employee at IDP is an ex-spouse of the user.
    1. The evil employee impersonates themselves as the User and gains access
        to RP1
    1. The evil employee looks at the user's dating history.
    1. The user is surprised by their ex-spouse's knowledge of their recent
        dating affairs.
</div>

<!-- ============================================================ -->
#### By Collusion #### {#attack-scenarios-by-idp-by-collusion}
<!-- ============================================================ -->

<!-- ============================================================ -->
##### Intrusion ##### {#attack-scenarios-by-idp-intrusion}
<!-- ============================================================ -->

   > From [[PRIVACY-THREAT-MODEL#hl-intrusion]]
   >
   > Privacy harms don't always come from a site learning things.

   > From [[RFC6973#section-5.1.3|RFC6973: Intrusion]]
   >
   > Intrusion consists of invasive acts that disturb or interrupt one's
   > life or activities.  Intrusion can thwart individuals' desires to be
   > left alone, sap their time or attention, or interrupt their
   > activities.

In the context of federation, intrusion happens when an RP and an IDP
are colluding to invasively and aggressively recommend the user to
login disproportionally to the their intent.

Much like unsolicited notifications, an [=RP=] can collude with an [=IDP=]
to aggressively log users in.

See also:
    1. [[DESIGN-PRINCIPLES#safe-to-browse]]

<!-- ============================================================ -->
##### Back channel ##### {#attack-scenarios-by-idp-back-channel}
<!-- ============================================================ -->

This attack scenario happens when IDP exceed the user’s information sharing
permission.

Existing federated identity protocols are clear on what information an RP
is requesting, which the IDP can provide. While the browser can inspect
the request and response and consider whether user permission has been
granted for that transfer, it is difficult to know that there is no
additional information embedded in the response. An example could be if
the IDP encodes an identifier that could be used to load user-targeted
advertisements on RP pages, which could be of value where the IDP has much
more profiling information about the user.

Another example is if identifying information is shared out-of-band,
invisible to the browser, in which case it could contain anything.

<div class="example">
    1. User signs into RP1 (which sells jewelry) with an IDP, providing to RP1
        their [=directed identifier=] email address SHA256(user + RP1)@email.example
    1. User signs into RP2 (which sells houses) with an IDP, providing to RP2
        their [=directed identifier=] email address SHA256(user + RP2)@email.example
    1. User browses the collection of wedding rings in RP1.
    1. Out of band, RP1 colludes with the IDP and exchanges
        SHA256(user + RP1)@email.example to user@email.example.
    1. RP1 tells RP2 that user@email.example is shopping for wedding rings
    1. User browses the housing inventory in RP2.
    1. Out of band, RP2 colludes with the IDP and exchanges
        SHA256(user + RP2)@email.example to user@email.example.
    1. RP2 uses the fact that the user is shopping for wedding rings in RP1 to
        advertise and filters their housing inventory.
    1. User is surprised that RP2 knows that they are shopping for wedding rings.
</div>

<!-- ============================================================ -->
##### Timing Attacks ##### {#attack-scenarios-by-idp-timing-attacks}
<!-- ============================================================ -->

The potential for IDPs profiling users based on their visits to RPs
[[#attack-scenarios-by-idp-secondary-use]] can be partially mitigated by hiding
the RP from the IDP until after the user has agreed to that tracking risk.

However, there is residual risk in cases where the RP and IDP are colluding.

If a credentialed request is sent to the IDP that does not explicitly identify
the RP, either of the following would still allow tracking by the IDP (again,
possibly not a _bona fide_ IDP that has existing knowledge of the user):

* The RP controlling any field in the request that can be used to convey
    identifying data in the request that the IDP could correlate to other
    requests from other RPs;

* The RP being able to provide fine-resolution timing information about
    the request to the IDP out of band.

The timing information can enable tracking in the following way:

    1. The RP logs the time at which it invoked the API, and
    1. The IDP logs the time at which it received a credentialed FedCM request
        from the user, and later
    1. They attempt to link the invocation and the request together using that
        information.

Notably, this is possible without FedCM using simple cross-origin top-level
navigations, but using FedCM for this purpose would worsen the problem if it
improved timing resolution or was less visible to users.

See also:
    1. [[DESIGN-PRINCIPLES#safe-to-browse]]

## Mitigation Strategies ## {#mitigation-strategies}

In this section we'll go over some strategies used in this specification to
mitigate the [privacy threats](#privacy-threat-model).

### Minimal Disclosure ### {#mitigation-minimal-disclosure}

There is a series of privacy threats that can be mitigated by disclosing the
least amount of identifying information and limiting its use as much as
possible. Two notable strategies are described in the sections below.

#### Directed Identifiers #### {#mitigation-directed-identifiers}

Mitigates:
    * [[#attack-scenarios-by-rp-cross-site-correlation]]

Note: directed, sharding, partitioning

The problem of RPs joining user data via back-channels is inherent
to the proliferation of identifying user data. This can be solved
by issuing [=directed identifiers=] that provide an effective handle
to a user's identity with a given IDP that is unique and therefore
cannot be correlated with other RPs.

In the past, there have been schemes to accomplish this using one-way
hashes of, for example, the user’s name, the IDP and the RP.

<div class="image">
  <pre class=include-raw>
  path: img/mock37.svg
  </pre>
</div>

Note: this mitigation is not robust against [[#attack-scenarios-by-idp-back-channel]],
or the [[#attack-scenarios-by-idp-secondary-use]]. Also, collaborating RPs might
be able to defeat this mitigation by sharing the same CLIENT_ID, although
possibly this could be detected and presumably would violate RP agreements with
IDPs with [[#mitigation-pre-registration]].

#### Self Presentation #### {#mitigation-self-presentation}

Mitigates:
    * [[#attack-scenarios-by-idp-secondary-use]] and
    * [[#attack-scenarios-by-idp-timing-attacks]]

Note: unbundling issuing from presentation

Preventing tracking of users by the IDP is difficult because the RP has to be
coded into the identity token for security reasons, to prevent reuse of the
token. There have been cryptographic schemes developed to blind the IDP to the
RP while still preventing token reuse in that way
(see Mozilla’s [personas](https://wiki.mozilla.org/Identity/Persona_AAR)) but
there are other valid uses that the IDP has for knowing the RP, such as fraud
and abuse prevention.

<div class="image">
  <pre class=include-raw>
  path: img/mock34.svg
  </pre>
</div>

### Mediation ### {#mitigation-mediation}

Mitigates:
    * [[#attack-scenarios-by-rp-cross-site-correlation]],
    * [[#attack-scenarios-by-rp-data-compromise]],
    * [[#attack-scenarios-by-idp-timing-attacks]]
    * [[#attack-scenarios-by-idp-intrusion]]

IDPs, whom the user has entrusted with their personal data, are currently
responsible for ensuring that the user consents to their information being
shared. With browser mediation in place, the user agent might have to assume
responsibility for ensuring the user understands what is being shared and that
it is intentional. This is certainly the case if the browser is able to entirely
intermediate the identity flow without showing any IDP web content, but also
might be desirable if there are concerns that the IDP is not collecting consent
in an adequate manner.

Additionally, a consent prompt preceding the sharing of the RP’s request to the
IDP can mitigate risks around IDP tracking of user visits to RPs.

<div class="image">
  <pre class=include-raw>
  path: img/mock46.svg
  </pre>
</div>

See also:
  1. [[DESIGN-PRINCIPLES#consent]]
  1. [[SELF-REVIEW#user-mediation]]
  1. [[RFC6973#page-23]]
  1. [[ETHICS|Ethical Principles]]: [[ETHICS#verify|The web must make it possible for people to verify the information they see]]
  1. [[ETHICS|Ethical Principles]]: [[ETHICS#control|The web must enhance individuals' control and power]]
  1. [[LEAST-POWER]]

#### Verification #### {#mitigation-verification}

Mitigates:
    * [[#attack-scenarios-by-rp-cross-site-correlation]],

The [=User Agent=] can mitigate [[#attack-scenarios-by-rp-cross-site-correlation]]
by inspecting the contents of the data exchange, and providing the necessary
user controls.

For example, it can inspect the email address that is being exchanged and verify
whether it is a [=directed identifier=] or not (and warn the user proportionally).

#### Activation #### {#activation}

The [=User Agent=] can mitigate [[#attack-scenarios-by-idp-intrusion]] by
mediating the user controls and offering them proportionally to the intent of
the user or the privacy risks involved.

For example, a [=User Agent=] can choose to show a loud / disruptive modal
mediated dialog when it has enough confidence of the user's intent or show a
quiet / conservative UI hint when it doesn't.

A [=User Agent=] could also choose to control disruption of the user's
experience based on the risks involved.

For example, when a [=directed identifier=] is being exchanged it can be more
confident of the unintended consequeces and offer a more aggressive user
experience, whereas when global identifiers are exchanged a more conservative
user experience.

<div class="image">
  <pre class=include-raw>
  path: img/mock45.svg
  </pre>
</div>

See also:
    * [Requiring user gesture to call WebAuthn API](https://github.com/w3c/webauthn/issues/1293)
    * [Require user gesture to request notification permissions](https://github.com/wicg/interventions/issues/49)
    * [WHATWG User Activation](https://html.spec.whatwg.org/multipage/interaction.html#tracking-user-activation)
    * [Querying User Activation](https://github.com/dtapuska/useractivation)

### Policy ### {#mitigation-policy}

Mitigates:
    * [[#attack-scenarios-by-idp-impersonation]],
    * [[#attack-scenarios-by-idp-back-channel]]

Beyond technical constraints, the browser can recognize explicit assertions by
the IDP about the privacy characteristics it provides and rely on those
assertions in order to guide the user appropriately. An example is a
hypothetical case in which the IDP asserts it will only issue
[=directed identifiers=] and will not provide identifying information to the
RPs out of view of the browser. In that case the browser may not have to warn
the user about sharing personalized information.

### Denylists ### {#mitigation-denylists}

Mitigates:
    * Potentially all threats, but is subject to the likelihood of bad behavior
        being detected, which for some might be difficult.

Any RPs or IDPs observed to be using this API to compromise user privacy in a
deceptive or abusive manner could be explicitly blocked from using it, or
potentially added to the SafeBrowsing blocklist so that they cannot be loaded
at all.

### Pre-registration ### {#mitigation-pre-registration}

Mitigates:
    * [[#attack-scenarios-by-rp-data-compromise]],
    * [[#attack-scenarios-by-rp-cross-site-correlation]]

Currently, IDPs require that an RP pre-registers and agrees to specific terms
before the IDP will issue an ID token to them.  This conflicts with
[the previous mitigation](#mitigation-self-presentation), but can provide a
measure of RP accountability.

### 2FA ### {#mitigation-2fa}

Mitigates:
    * [[#attack-scenarios-by-idp-impersonation]],

<!-- ====================================================================== -->
# Extensibility # {#extensibility}
<!-- ====================================================================== -->

Note: go over the extensibility mechanisms.

<!-- ====================================================================== -->
# Acknowledgements # {#acknowledgements}
<!-- ====================================================================== -->

Note: write down the Acknowledgements section.

<pre class="biblio">
{
  "CM": {
    "href": "https://w3c.github.io/webappsec-credential-management/",
    "title": "Credential Management"
  },
  "ETHICS": {
   "href": "https://www.w3.org/2001/tag/doc/ethical-web-principles",
   "title": "W3C TAG Ethical Web Principles"
  },
  "FINGERPRINTING-GUIDANCE": {
    "href": "https://w3c.github.io/fingerprinting-guidance/",
    "title": "Mitigating Browser Fingerprinting in Web Specifications"
  },
  "Front-Channel-Logout": {
    "authors": [ "M. Jones" ],
    "href": "https://openid.net/specs/openid-connect-frontchannel-1_0.html",
    "title": "Front-Channel Logout"
  },
  "Identity-Use-Cases-in-Browser-Catalog": {
    "authors": [ "V. Bertocci", "G. Fletcher" ],
    "href": "https://datatracker.ietf.org/doc/html/draft-bertocci-identity-in-browser-00",
    "title": "Identity Use Cases in Browser Catalog"
  },
  "JWT": {
    "authors": [ "M. Jones", "J. Bradley", "N. Sakimura" ],
    "href": "https://datatracker.ietf.org/doc/html/rfc7519",
    "title": "JWT"
  },
  "OAuth": {
    "authors": ["D. Hardt"],
    "href": "https://datatracker.ietf.org/doc/html/rfc6749",
    "title": "OAuth"
  },
  "OIDC-Connect-Core": {
    "href": "https://openid.net/specs/openid-connect-core-1_0.html",
    "title": "OIDC Connect Core"
  },
  "OpenID": {
    "href": "https://openid.net/developers/specs/",
    "title": "OpenID"
  },
  "PRINCIPLES": {
    "href": "https://w3ctag.github.io/design-principles",
    "title": "Web Platform Design Principles"
  },
  "PRIVACY-CONSIDERATIONS": {
    "href": "https://w3c.github.io/privacy-considerations/",
    "title": "Privacy Considerations for Web Protocols"
  },
  "PRIVACY-MODEL": {
    "href": "https://github.com/michaelkleber/privacy-model",
    "title": "Privacy Model"
  },
  "PRIVACY-THREAT-MODEL": {
    "href": "https://w3cping.github.io/privacy-threat-model/",
    "title": "Target Privacy Threat Model"
  },
  "PSL-PROBLEMS": {
    "authors": ["Ryan Sleevi"],
    "href": "https://github.com/sleevi/psl-problems",
    "title": "Public Suffix List Problems"
  },
  "RFC6973": {
    "href": "https://datatracker.ietf.org/doc/html/rfc6973",
    "title": "Privacy Considerations for Internet Protocols"
  },
  "RFC7258": {
    "href": "https://datatracker.ietf.org/doc/html/rfc7258",
    "title": "Pervasive Monitoring Is an Attack"
  },
  "SAML": {
    "href": "http://saml.xml.org/saml-specifications",
    "title": "SAML"
  },
  "SAML-Glossary": {
    "href": "https://docs.oasis-open.org/security/saml/v2.0/saml-glossary-2.0-os.pdf",
    "title": "SAML glossary"
  },
  "Security-Origin-Confusion": {
    "href": "https://w3c.github.io/webappsec-credential-management/#security-origin-confusion",
    "title": "Security Origin Confusion"
  },
  "SELF-REVIEW": {
    "href": "https://www.w3.org/TR/security-privacy-questionnaire/",
    "title": "Self-Review Questionnaire: Security and Privacy"
  }
}
</pre>
